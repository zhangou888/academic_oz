blogdown:::new_post_addin()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
names(xaringan:::list_css())
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::new_post_addin()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
grep("uk", names(emo::ji_name), value = TRUE, ignore.case = TRUE)
grep("forbid", names(emo::ji_name), value = TRUE, ignore.case = TRUE)
grep("forbidden", names(emo::ji_name), value = TRUE, ignore.case = TRUE)
library(emo)
grep("forbidden", names(emo::ji_name), value = TRUE, ignore.case = TRUE)
grep("forbid", names(emo::ji_name), value = TRUE, ignore.case = TRUE)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::new_post_addin()
## Step 2: load required packages
packages <- c("tidyverse", "knitr")
packages <- lapply(packages, FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x)
library(x, character.only = TRUE)
}
})
knitr::include_graphics("img/figure1.png", error = FALSE)
knitr::include_graphics("img/figure2.png", error = FALSE)
knitr::include_graphics("img/figure3.png", error = FALSE)
knitr::include_graphics("img/figure4.png", error = FALSE)
knitr::include_graphics("img/figure5.png", error = FALSE)
knitr::include_graphics("img/figure5.png", error = FALSE)
knitr::include_graphics("img/figure7.png", error = FALSE)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
## Step 2: load required packages
packages <- c("tidyverse","rmarkdown","knitr")
packages <- lapply(packages, FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x)
library(x, character.only = TRUE)
}
})
# install.packages("devtools")
library(devtools)
devtools::install_github("garrettgman/DSR")
devtools::install_github("uc-cfss/rcfss")
library(tidyr)
library(dplyr)
library(DSR)
library(rcfss)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
library(tidyverse)
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4) %>%
plot() %>%
summary()
mtcars %>%
filter(carb > 1)
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4) %>%
plot() %>%
summary()
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4)
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4) %T>%
plot() %>%
summary()
install.packages(c("broom", "dbplyr", "DiagrammeR", "ellipsis", "mirt", "mnormt", "modelr", "openxlsx", "ps", "raster", "RcppArmadillo", "reshape2", "rex", "scales", "sp", "tidyr", "tidyselect", "tinytex", "vctrs", "xml2"))
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib="C:/R/win-library/3.6")
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib = "C:/R/win-library/3.6")
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib = "C:/R/win-library/3.6")
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib = "C:/R/win-library/3.6")
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib = "C:/R/win-library/3.6")
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib = "C:/R/win-library/3.6")
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib = "C:/R/win-library/3.6")
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib = "C:/R/win-library/3.6")
install.packages(c("backports", "bookdown", "doBy", "git2r", "glue", "purrr", "Rcpp", "rematch2", "rlang", "scales", "tinytex", "usethis", "withr", "xfun"), lib = "C:/R/win-library/3.6")
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4) %>%
plot() %>%
summary()
library(tidyverse)
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4) %>%
plot() %>%
summary()
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4) %T>%
plot() %>%
summary()
library(rlang)
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4) %>%
plot() %>%
summary()
# inserting %T>% allows you to plot and perform the functions that
# follow the plotting function
mtcars %>%
filter(carb > 1) %>%
extract(, 1:4) %T>%
plot() %>%
summary()
library(dplyr)
df <- data.frame(a=1:10)
df %>% filter(a>4)
library(babynames) # data package
library(dplyr)     # provides data manipulating functions.
library(magrittr)  # ceci n'est pas un pipe
library(ggplot2)   # for graphics
babynames %>%
filter(name %>% substr(1, 3) %>% equals("Ste")) %>%
group_by(year, sex) %>%
summarize(total = sum(n)) %>%
qplot(year, total, color = sex, data = ., geom = "line") %>%
add(ggtitle('Names starting with "Ste"')) %>%
print
babynames %>%
filter(name %>% substr(1, 3) %>% equals("Ste")) %>%
group_by(year, sex) %>%
summarize(total = sum(n)) %>%
qplot(year, total, color = sex, data = ., geom = "line") %>%
add(ggtitle('Names starting with "Ste"')) %>%
print()
tryCatch(stop("!"), error = function(e) "An error")
#> [1] "An error"
stop("!") %>%
tryCatch(error = function(e) "An error")
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::update_meta_addin()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
## Step 2: load required packages
packages <- c("boot","dplyr","ggvis","tidyverse",
"ggplot2","psychTools","ISLR")
packages <- lapply(packages, FUN = function(x) {
if (!require(x, character.only = TRUE)) {
install.packages(x)
library(x, character.only = TRUE)
}
})
library("knitr")
head(Default)
str(Default)
library(ISLR)
library(dplyr)
library(ggvis)
library(boot)
# Basic scatter plot
ggplot(Default, aes(x=balance, y=income, shape=default, color=default)) + geom_point()
ggplot(Default) + aes(x = default, y = balance, color=default) +
geom_boxplot(outlier.colour="red", outlier.shape=2,
outlier.size=1)
glm(default~balance + student + income, family = "binomial", data = Default)
my_logit <- glm(default~balance + student + income, family = "binomial", data = Default)
anova(my_logit, test = "Chisq")
summary(my_logit)
ggplot(Default) + aes(x = student, y = balance, color=student) +
geom_boxplot(outlier.colour="red", outlier.shape=2,
outlier.size=1)
set.seed(1)
# Create a sample of 5000 observations
train <- sample(10000,5000)
train
dim(train)
length(train)
dim(Default)
# Generate Defaultx (test data)
Defaultx <- Default[-train,]
# Fit the logistic model using the training data.
# Be aware of the subset option (subset=train).
glm.fit <- glm(default~ balance + student, data = Default, family = binomial, subset = train)
glm.fit
# Use the logistic model to fit the same logistic model, but use the test data.
glm.probs <- predict(glm.fit, Defaultx, type = "response")
# Make a vector that contains 5000 no responses.
glm.pred <- rep("No", 5000)
glm.probs
dim(glm.pred)
length(glm.pred)
# Replace the "no reponses" in the glm.pred vector where the probability is greater than 50% with "Yes"
glm.pred[glm.probs > .5] = "Yes"
# Create a vector that contains the defaults from the testing data set, Defaultx
defaultVector <- Defaultx$default
# Calculate the mean of the values where the predicted value from the training equals the held out set.
mean(glm.pred == defaultVector)
pct_df
pct_df <- paste(mean_df,"%",sep="")
# Calculate the mean of the values where the predicted value from the training equals the held out set.
mean_df <- mean(glm.pred == defaultVector)
pct_df <- paste(mean_df,"%",sep="")
pct_df
pct_df <- paste(100*mean_df,"%",sep="")
pct_df
# Seed the random number generator
set.seed(2)
# Fit a logistic model using default and income values
glm.fit1 <- glm(default~balance + student, data = Default, family = binomial)
# Create a vector with three blank values
cv.error <- rep(0,3)
# Store the results of each K  validation set into cv.error.  Use K= {3,5,10}
cv.error[1] <- cv.glm(Default, glm.fit1, K=3)$delta[1]
# Store the results of each K  validation set into cv.error.  Use K= {3,5,10}
cv.error[1] <- cv.glm(Default, glm.fit1, K=3)$delta[1]
cv.error[2] <- cv.glm(Default, glm.fit1, K=5)$delta[1]
cv.error[3] <- cv.glm(Default, glm.fit1, K=10)$delta[1]
cv.error[3] <- cv.glm(Default, glm.fit1, K=10)$delta[1]
1 - mean(cv.error)
# Set up the random number generator so that others can repeat results
set.seed(1)
# Create a sample of 5000 observations
train <- sample(10000,5000)
# Defaultx is a subset of the Default data that does not include the training data that
# we will fit the model on
Defaultx <- Default[-train,]
# Fit the logistic model using the training data.
glm.fit <- glm(default~income + balance + student, data = Default,
family = binomial, subset = train)
# Use the logistic model to fit the same logistic model, but use the test data.
glm.probs <- predict(glm.fit, Defaultx, type = "response")
# Make a vector that contains 5000 no responses.
glm.pred <- rep("No", 5000)
# Replace the no reponsees in the glm.pred vector where the probability is greater than 50% with "Yes"
glm.pred[glm.probs > .5] = "Yes"
# Create a vector that contains the defaults from the testing data set, Defaultx
defaultVector <- Defaultx$default
# Calculate the mean of the values where the predicted value from the training equals the held out set.
mean(glm.pred == defaultVector)
# Fit the logistic model using the training data.
glm.fit <- glm(default~income + balance + student, data = Default,
family = binomial, subset = train)
# Use the logistic model to fit the same logistic model, but use the test data.
glm.probs <- predict(glm.fit, Defaultx, type = "response")
# Make a vector that contains 5000 no responses.
glm.pred <- rep("No", 5000)
# Replace the no reponsees in the glm.pred vector where the probability is greater than 50% with "Yes"
glm.pred[glm.probs > .5] = "Yes"
# Create a vector that contains the defaults from the testing data set, Defaultx
defaultVector <- Defaultx$default
# Calculate the mean of the values where the predicted value from the training equals the held out set.
mean(glm.pred == defaultVector)
blogdown:::serve_site()
blogdown:::serve_site()
blogdown:::serve_site()
